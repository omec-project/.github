# Copyright 2025 Canonical Ltd.
# SPDX-FileCopyrightText: 2025-Present Intel Corporation
# SPDX-License-Identifier: Apache-2.0
name: E2E tests

on:
  workflow_call:
    inputs:
      branch_name:
        description: "Name of the branch to checkout"
        required: false
        type: string
        default: ${{ github.ref }}

jobs:
  e2e-tests:
    runs-on: ubuntu-latest
    env:
      NAMESPACE: aether-5gc
    steps:
      - name: Checkout repository
        uses: actions/checkout@v6

      - name: Update and install dependencies
        run: |
          set -e
          sudo apt update
          sudo apt-get install -y conntrack socat ipset ebtables ansible-core
          sudo apt install -y sshpass python3-venv pipx make git
          pipx install --include-deps ansible
          echo "$HOME/.local/bin" >> "$GITHUB_PATH"

      - name: Generate SSH Key
        run: |
          set -e
          ssh-keygen -t rsa -b 2048 -f ~/.ssh/id_rsa -N "" -q
          cat ~/.ssh/id_rsa.pub >> ~/.ssh/authorized_keys

      - name: Clone aether-onramp repository
        run: |
          set -e
          REPO_URL="https://github.com/opennetworkinglab/aether-onramp.git"
          # Pin to a specific commit/tag for reproducible CI runs
          AETHER_ONRAMP_REF="main"
          # Clone to parent directory to avoid polluting current workspace
          AETHER_ONRAMP_DIR="${GITHUB_WORKSPACE}/../aether-onramp"
          if ! git clone --recursive --branch "${AETHER_ONRAMP_REF}" --depth 1 ${REPO_URL} "${AETHER_ONRAMP_DIR}"; then
            echo "ERROR: Failed to clone aether-onramp repository from ${REPO_URL}" >&2
            exit 1
          fi
          cd "${AETHER_ONRAMP_DIR}"
          echo "=== aether-onramp commit used ==="
          git log -1 --format="Commit: %H%nAuthor: %an%nDate: %ad%nMessage: %s"
          # Export for use in subsequent steps
          echo "AETHER_ONRAMP_DIR=${AETHER_ONRAMP_DIR}" >> "$GITHUB_ENV"

      - name: Update files
        run: |
          set -e
          INTERFACE=$(ip route | awk '/default/ {print $5}')
          IP_ADDR=$(ip -4 addr show ${INTERFACE} | grep -oP '(?<=inet\s)\d+(\.\d+){3}')
          if [ -z "${IP_ADDR}" ]; then
            echo "Failed to extract IP address" >&2
            exit 1
          fi
          echo "Extracted IP: ${IP_ADDR}"
          echo "[all]" > "${AETHER_ONRAMP_DIR}/hosts.ini"
          echo "node1 ansible_host=${IP_ADDR} ansible_user=runner ansible_ssh_private_key_file=~/.ssh/id_rsa" >> "${AETHER_ONRAMP_DIR}/hosts.ini"
          echo "" >> "${AETHER_ONRAMP_DIR}/hosts.ini"
          echo "[master_nodes]" >> "${AETHER_ONRAMP_DIR}/hosts.ini"
          echo "node1" >> "${AETHER_ONRAMP_DIR}/hosts.ini"
          echo "" >> "${AETHER_ONRAMP_DIR}/hosts.ini"
          echo "[worker_nodes]" >> "${AETHER_ONRAMP_DIR}/hosts.ini"
          echo "" >> "${AETHER_ONRAMP_DIR}/hosts.ini"
          echo "[gnbsim_nodes]" >> "${AETHER_ONRAMP_DIR}/hosts.ini"
          echo "node1" >> "${AETHER_ONRAMP_DIR}/hosts.ini"
          sed -i "s/ens18/eth0/" "${AETHER_ONRAMP_DIR}/vars/main.yml"
          sed -i "s/10.76.28.113/${IP_ADDR}/" "${AETHER_ONRAMP_DIR}/vars/main.yml"
          sed -i "s/300s/600s/" "${AETHER_ONRAMP_DIR}/deps/k8s/roles/rke2/tasks/install.yml"
          sed -i '99d' "${AETHER_ONRAMP_DIR}/deps/k8s/roles/rke2/tasks/install.yml"
          sed -i "s/2m30s/10m/" "${AETHER_ONRAMP_DIR}/deps/5gc/roles/core/tasks/install.yml"

      - name: Test aether-pingall
        run: |
          set -e
          cd "${AETHER_ONRAMP_DIR}"
          make aether-pingall

      - name: Install aether-k8s
        run: |
          set -e
          cd "${AETHER_ONRAMP_DIR}"
          make aether-k8s-install

      - name: Install 5G Core
        run: |
          set -e
          cd "${AETHER_ONRAMP_DIR}"
          make aether-5gc-install

      - name: Patch K8s Deployment to attach local image
        run: |
          set -ex
          REPO_NAME=$(echo "${GITHUB_REPOSITORY}" | cut -d'/' -f2)

          # Use the repository already checked out in the workspace
          cd "${GITHUB_WORKSPACE}"

          # webconsole uses 'webui' as the image name
          IMAGE_NAME="${REPO_NAME/webconsole/webui}"

          # Set up a local registry to serve the image
          echo "=== Starting local registry ==="
          docker run -d -p 5000:5000 --name registry registry:2

          # Build and push to local registry
          LOCAL_IMAGE_NAME="localhost:5000/${IMAGE_NAME}:testing"
          echo "=== Building Docker image ${LOCAL_IMAGE_NAME} ==="
          if ! docker build -t "${LOCAL_IMAGE_NAME}" .; then
            echo "Docker build failed, aborting."
            exit 1
          fi

          echo "=== Pushing Docker image ${LOCAL_IMAGE_NAME} to local registry ==="
          if ! docker push "${LOCAL_IMAGE_NAME}"; then
            echo "Docker push failed, aborting."
            exit 1
          fi

          echo "=== Verifying image in local registry ==="
          curl -f -X GET http://localhost:5000/v2/${IMAGE_NAME}/tags/list

          # Verify deployment exists before patching
          echo "=== Checking deployment exists ==="
          if ! kubectl -n "$NAMESPACE" get deployment "$REPO_NAME" &>/dev/null; then
            echo "ERROR: Deployment ${REPO_NAME} not found in namespace ${NAMESPACE}" >&2
            kubectl -n "$NAMESPACE" get deployments
            exit 1
          fi

          # Find the container index by name
          echo "=== Finding container index ==="
          CONTAINER_INDEX=$(kubectl -n "$NAMESPACE" get deployment "$REPO_NAME" -o jsonpath="{.spec.template.spec.containers[*].name}" | tr ' ' '\n' | grep -n "^${IMAGE_NAME}$" | cut -d: -f1)
          if [ -z "$CONTAINER_INDEX" ]; then
            echo "ERROR: Container '${IMAGE_NAME}' not found in deployment ${REPO_NAME}" >&2
            echo "Available containers:" >&2
            kubectl -n "$NAMESPACE" get deployment "$REPO_NAME" -o jsonpath='{.spec.template.spec.containers[*].name}'
            exit 1
          fi
          # Convert to 0-based index
          CONTAINER_INDEX=$((CONTAINER_INDEX - 1))
          echo "Found container '${IMAGE_NAME}' at index ${CONTAINER_INDEX}"

          # Patch K8s deployment to use local registry
          echo "=== Patching deployment ==="
          kubectl -n "$NAMESPACE" patch deployment "$REPO_NAME" --type="json" -p="[
            {\"op\": \"replace\", \"path\": \"/spec/template/spec/containers/${CONTAINER_INDEX}/image\", \"value\": \"${LOCAL_IMAGE_NAME}\"},
            {\"op\": \"replace\", \"path\": \"/spec/template/spec/containers/${CONTAINER_INDEX}/imagePullPolicy\", \"value\": \"Always\"}
          ]"

          echo "=== Verifying deployment patch ==="
          kubectl -n "$NAMESPACE" get deployment "$REPO_NAME" -o jsonpath="{.spec.template.spec.containers[${CONTAINER_INDEX}].image}{\"\n\"}"
          kubectl -n "$NAMESPACE" get deployment "$REPO_NAME" -o jsonpath="{.spec.template.spec.containers[${CONTAINER_INDEX}].imagePullPolicy}{\"\n\"}"

          echo "=== Waiting for pod to be ready ==="
          # Allow overriding the rollout timeout via K8S_ROLLOUT_TIMEOUT (e.g. '300s', '600s'); default is 300s
          ROLLOUT_TIMEOUT="${K8S_ROLLOUT_TIMEOUT:-300s}"
          kubectl -n "$NAMESPACE" rollout status deployment "$REPO_NAME" --timeout="${ROLLOUT_TIMEOUT}" || {
            echo "=== Rollout failed after timeout ${ROLLOUT_TIMEOUT}, checking pod status ==="
            kubectl -n "$NAMESPACE" get pods -l app="${IMAGE_NAME}"
            kubectl -n "$NAMESPACE" describe pods -l app="${IMAGE_NAME}"
            exit 1
          }

      - name: Wait for network function to sync up with others
        run: |
          set -e
          echo "Waiting for all pods in aether-5gc namespace to be Ready..."
          kubectl wait --for=condition=ready pod --all -n aether-5gc --timeout=300s

      - name: Install GNBSIM
        run: |
          set -e
          cd "${AETHER_ONRAMP_DIR}"
          make aether-gnbsim-install

      - name: Perform tests
        run: |
          set -e
          cd "${AETHER_ONRAMP_DIR}"
          make aether-gnbsim-run

      - name: Validate results
        run: |
          set -e
          # Capture summary.log contents and verify it exists
          status=$(docker exec gnbsim-1 cat summary.log 2>/dev/null) || {
            echo "Failed to read summary.log from gnbsim-1 container."
            exit 1
          }

          if [ -z "$status" ]; then
            echo "summary.log is missing or empty."
            exit 1
          fi

          if echo "$status" | grep -q "Profile Status: PASS"; then
            echo "Profile Status is successful."
            echo "summary.log contents:"
            echo "$status"
          else
            echo "Profile Status does not indicate success (expected 'Profile Status: PASS')."
            echo "summary.log contents:"
            echo "$status"
            exit 1
          fi

      - name: Cleanup local registry
        if: always()
        run: |
          if docker ps -a --format '{{.Names}}' | grep -q '^registry$'; then
            echo "Stopping and removing local registry container..."
            docker stop registry || true
            docker rm registry || true
          fi

      - name: Dump all pod logs in aether-5gc namespace
        if: always()
        run: |
          set -ex
          REPO_NAME=$(echo "${GITHUB_REPOSITORY}" | cut -d'/' -f2)
          # webconsole uses 'webui' as the app label
          APP_LABEL="${REPO_NAME/webconsole/webui}"

          mkdir -p logs
          kubectl get events -A --sort-by='.lastTimestamp' > logs/events.log
          kubectl get pods -n "$NAMESPACE" -o wide > logs/pods-summary.log
          for pod in $(kubectl get pods -n "$NAMESPACE" -o jsonpath='{.items[*].metadata.name}'); do
            if ! kubectl logs --all-containers -n "$NAMESPACE" "$pod" > "logs/${pod}.log" 2>&1; then
              echo "Failed to collect logs for pod ${pod} using '--all-containers'; attempting fallback without the flag." | tee -a logs/log-collection-errors.log
              if ! kubectl logs -n "$NAMESPACE" "$pod" >> "logs/${pod}.log" 2>&1; then
                echo "Fallback log collection for pod ${pod} without '--all-containers' also failed." | tee -a logs/log-collection-errors.log
              fi
            fi
          done
          for pod in $(kubectl get pods -n "$NAMESPACE" -l app="${APP_LABEL}" -o jsonpath='{.items[*].metadata.name}'); do
            kubectl describe pod -n "$NAMESPACE" "$pod" > "logs/${pod}-describe.log" 2>&1 || true
          done
          docker exec gnbsim-1 cat gnbsim.log > logs/gnbsim.log 2>&1 || true

      - name: Upload pod logs
        if: always()
        uses: actions/upload-artifact@v6.0.0
        with:
          name: aether-5gc-logs
          path: logs/
