# Copyright 2025 Canonical Ltd.
# SPDX-FileCopyrightText: 2025-Present Intel Corporation
# SPDX-License-Identifier: Apache-2.0
name: E2E tests

on:
  workflow_call:
    inputs:
      branch_name:
        description: "Name of the branch to checkout"
        required: false
        type: string
        default: ${{ github.ref }}

jobs:
  e2e-tests:
    runs-on: ubuntu-latest
    env:
      NAMESPACE: aether-5gc
    steps:
      - name: Checkout repository
        uses: actions/checkout@v6

      - name: Set image names
        run: |
          REPO_NAME=$(echo "${GITHUB_REPOSITORY}" | cut -d'/' -f2)
          # webconsole uses 'webui' as the image name
          IMAGE_NAME="${REPO_NAME/webconsole/webui}"
          LOCAL_IMAGE_NAME="localhost:5000/${IMAGE_NAME}:testing"
          echo "REPO_NAME=${REPO_NAME}" >> "$GITHUB_ENV"
          echo "IMAGE_NAME=${IMAGE_NAME}" >> "$GITHUB_ENV"
          echo "LOCAL_IMAGE_NAME=${LOCAL_IMAGE_NAME}" >> "$GITHUB_ENV"
          echo "Repository: ${REPO_NAME}"
          echo "Image name: ${IMAGE_NAME}"
          echo "Local image name: ${LOCAL_IMAGE_NAME}"

      - name: Update and install dependencies
        run: |
          set -e
          sudo apt update
          # Kubernetes dependencies
          sudo apt-get install -y conntrack socat ipset ebtables
          # Build and automation tools
          sudo apt install -y pipx make python3-yaml
          # Install Ansible via pipx for aether-onramp
          pipx install --include-deps ansible
          echo "$HOME/.local/bin" >> "$GITHUB_PATH"

      - name: Generate SSH Key
        run: |
          set -e
          # NOTE: This job runs on a GitHub-hosted runner. The VM and its filesystem
          # are ephemeral and destroyed after the job completes, so this SSH key does
          # not persist beyond the lifetime of this workflow run.
          mkdir -p ~/.ssh
          chmod 700 ~/.ssh
          ssh-keygen -t rsa -b 2048 -f ~/.ssh/id_rsa -N "" -q
          cat ~/.ssh/id_rsa.pub >> ~/.ssh/authorized_keys
          chmod 600 ~/.ssh/authorized_keys

      - name: Clone aether-onramp repository
        run: |
          set -e
          REPO_URL="https://github.com/opennetworkinglab/aether-onramp.git"
          # Pin to a specific commit/tag for reproducible CI runs
          AETHER_ONRAMP_REF="main"
          # Clone to parent directory to avoid polluting current workspace
          AETHER_ONRAMP_DIR="${GITHUB_WORKSPACE}/../aether-onramp"
          if ! git clone --recursive --branch "${AETHER_ONRAMP_REF}" --depth 1 ${REPO_URL} "${AETHER_ONRAMP_DIR}"; then
            echo "ERROR: Failed to clone aether-onramp repository from ${REPO_URL}" >&2
            exit 1
          fi
          cd "${AETHER_ONRAMP_DIR}"
          echo "=== aether-onramp commit used ==="
          git log -1 --format="Commit: %H%nAuthor: %an%nDate: %ad%nMessage: %s"
          # Export for use in subsequent steps
          echo "AETHER_ONRAMP_DIR=${AETHER_ONRAMP_DIR}" >> "$GITHUB_ENV"

      - name: Update aether-onramp configuration files
        run: |
          # Update all configuration: hosts.ini, timeouts, and sd-core values with local image
          .github/scripts/update-aether-files.py "${AETHER_ONRAMP_DIR}" "${IMAGE_NAME}" "${LOCAL_IMAGE_NAME}"

      - name: Check values file
        run: |
          cat "${AETHER_ONRAMP_DIR}/deps/5gc/roles/core/templates/sdcore-5g-values.yaml"

      - name: Test aether-pingall
        run: |
          set -e
          cd "${AETHER_ONRAMP_DIR}"
          make aether-pingall

      - name: Install aether-k8s
        run: |
          set -e
          cd "${AETHER_ONRAMP_DIR}"
          make aether-k8s-install

      - name: Build and push local image to registry
        run: |
          set -ex

          # Use the repository already checked out in the workspace
          cd "${GITHUB_WORKSPACE}"

          # Set up a local registry to serve the image; use host networking to avoid exposing an extra mapped port
          echo "=== Starting local registry ==="
          docker run -d --network host --name registry registry:2

          # Build and push to local registry
          LOCAL_IMAGE_NAME="localhost:5000/${IMAGE_NAME}:testing"
          echo "=== Building Docker image ${LOCAL_IMAGE_NAME} ==="
          if ! docker build -t "${LOCAL_IMAGE_NAME}" .; then
            echo "Docker build failed, aborting."
            exit 1
          fi

          echo "=== Pushing Docker image ${LOCAL_IMAGE_NAME} to local registry ==="
          if ! docker push "${LOCAL_IMAGE_NAME}"; then
            echo "Docker push failed, aborting."
            exit 1
          fi

          echo "=== Verifying image in local registry ==="
          curl -f -X GET http://localhost:5000/v2/${IMAGE_NAME}/tags/list

      - name: Install 5G Core
        run: |
          set -e
          cd "${AETHER_ONRAMP_DIR}"
          make aether-5gc-install

      - name: Pods status
        run: |
          set -e
          echo "Pods status"
          kubectl get pods -n "$NAMESPACE"

      - name: Install GNBSIM
        run: |
          set -e
          cd "${AETHER_ONRAMP_DIR}"
          make aether-gnbsim-install

      - name: Perform tests
        run: |
          set -e
          cd "${AETHER_ONRAMP_DIR}"
          make aether-gnbsim-run

      - name: Validate results
        run: |
          set -e
          # Capture summary.log contents and verify it exists
          status=$(docker exec gnbsim-1 cat summary.log 2>/dev/null) || {
            echo "Failed to read summary.log from gnbsim-1 container."
            exit 1
          }

          if [ -z "$status" ]; then
            echo "summary.log is missing or empty."
            exit 1
          fi

          if echo "$status" | grep -q "Profile Status: PASS"; then
            echo "Profile Status is successful."
            echo "summary.log contents:"
            echo "$status"
          else
            echo "Profile Status does not indicate success (expected 'Profile Status: PASS')."
            echo "summary.log contents:"
            echo "$status"
            exit 1
          fi

      - name: Cleanup local registry
        if: always()
        run: |
          if docker ps -a --format '{{.Names}}' | grep -q '^registry$'; then
            echo "Stopping and removing local registry container..."
            docker stop registry || true
            docker rm registry || true
          fi

      - name: Dump all pod logs in aether-5gc namespace
        if: always()
        run: |
          set -ex

          mkdir -p logs
          kubectl get events -A --sort-by='.lastTimestamp' > logs/events.log
          kubectl get pods -n "$NAMESPACE" -o wide > logs/pods-summary.log
          for pod in $(kubectl get pods -n "$NAMESPACE" -o jsonpath='{.items[*].metadata.name}'); do
            if ! kubectl logs --all-containers -n "$NAMESPACE" "$pod" > "logs/${pod}.log" 2>&1; then
              echo "Failed to collect logs for pod ${pod} using '--all-containers'; attempting fallback without the flag." | tee -a logs/log-collection-errors.log
              if ! kubectl logs -n "$NAMESPACE" "$pod" >> "logs/${pod}.log" 2>&1; then
                echo "Fallback log collection for pod ${pod} without '--all-containers' also failed." | tee -a logs/log-collection-errors.log
              fi
            fi
          done
          for pod in $(kubectl get pods -n "$NAMESPACE" -l app="${IMAGE_NAME}" -o jsonpath='{.items[*].metadata.name}'); do
            kubectl describe pod -n "$NAMESPACE" "$pod" > "logs/${pod}-describe.log" 2>&1 || true
          done
          docker exec gnbsim-1 cat gnbsim.log > logs/gnbsim.log 2>&1 || true

      - name: Upload pod logs
        if: always()
        uses: actions/upload-artifact@v6.0.0
        with:
          name: aether-5gc-logs
          path: logs/
